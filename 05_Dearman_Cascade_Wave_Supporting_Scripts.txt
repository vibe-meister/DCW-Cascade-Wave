Supporting Computational Scripts

This file contains code examples and snippets for DIM simulations.
For the complete, production-ready implementation, see: 12_Implied_Magnetism_Model.py

# Example Python Script for DIM Simulations

import numpy as np
from scipy.integrate import odeint

class DIMSimulator:
    """
    Simplified DIM simulator for quick testing.
    Full implementation available in 12_Implied_Magnetism_Model.py
    """
    def __init__(self, Re=2000, dim_on=True):
        self.Re = Re
        self.dim_on = dim_on
        self.res_freqs = [3, 6, 9, 12, 18, 24, 48, 75]
        self.larmor_omega = 0.1
        self.alpha = 0.05
        self.beta = 0.1

    def resonance_term(self, field, t):
        """Resonance amplification for 3-6-9 patterns"""
        if not self.dim_on:
            return 0
        return self.alpha * sum(np.sin(2*np.pi*f*t) for f in self.res_freqs) * field

    def run_sweep(self, Re_list):
        """Run Reynolds number sweep"""
        results = []
        for Re in Re_list:
            self.Re = Re
            # Simulate...
            breakdown = self.has_breakdown()
            gamma_max = self.max_gamma()
            results.append((Re, breakdown, gamma_max))
        return results

# Usage:
Re_list = np.arange(1500, 3100, 200)
sim = DIMSimulator(dim_on=True)
print(sim.run_sweep(Re_list))

# 3D Precession Extension (Hopf Amplitude Equation)
def amplitude_eqn(t, A, mu=0.1, omega=0.04, l=1, res_freqs=[0.3,0.6,0.9], dim_on=True):
    """
    DIM-extended Hopf normal form:
    dA/dt = (μ + iω) A - l |A|^2 A + F_res(t) + i Δω_L A
    """
    dA_dt = (mu + 1j*omega) * A - l * abs(A)**2 * A
    if dim_on:
        for f in res_freqs:
            dA_dt += 0.05 * np.exp(1j * 2*np.pi * f * t)
        # Larmor frequency shift
        dA_dt += 1j * 0.1 * 0.1 * A  # i β ω_L A
    return dA_dt

# Integrate with scipy.integrate.odeint
t = np.linspace(0, 2000, 20000)
y0 = [0.1, 0.0]  # [Re(A), Im(A)]
sol_dim = odeint(amplitude_eqn, y0, t, args=(0.1, 0.04, 1.0, [0.3,0.6,0.9], True))

# Compute PSD for spectral analysis
from scipy.signal import welch
A = sol_dim[:, 0] + 1j * sol_dim[:, 1]
f, psd = welch(np.abs(A), 1.0/(t[1]-t[0]), nperseg=len(t)//4)

# Expected results with DIM:
# - Primary peak at St ≈ 0.04 (natural frequency)
# - Sidebands at St = 0.04 ± 0.3k (resonance frequencies)
# - Amplified power (~14× compared to standard)

